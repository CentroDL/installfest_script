#!/usr/bin/env bash
# Subject="Log"
# Receipients="philco@ga.co"
# Message_Success="Done"
# { echo -e "$Message_Success\n\n" ; cat $Path_Log_file ; } | mail -s "$Subject" "$Recipients"

mkdir -p ~/.wdi # must make this here in order to store the log file
exec > >(tee ~/.wdi/install.log)

# http://stackoverflow.com/questions/3173131/redirect-copy-of-stdout-to-log-file-from-within-bash-script-itself
# Without this, only stdout would be captured - i.e. your
# log file would not contain any error messages.
# SEE answer by Adam Spiers, which keeps STDERR a seperate stream -
# I did not want to steal from him by simply adding his answer to mine.
exec 2>&1

echo "Script executed at $(date)"
echo ""
#
#  _           _        _ _  __           _
# (_)_ __  ___| |_ __ _| | |/ _| ___  ___| |_
# | | '_ \/ __| __/ _` | | | |_ / _ \/ __| __|
# | | | | \__ \ || (_| | | |  _|  __/\__ \ |_
# |_|_| |_|___/\__\__,_|_|_|_|  \___||___/\__|
#
# Installfest Script for development

# Author: Phillip Lamplugh, GA Instructor (2014)
# Contributions: PJ Hughes, GA Instructor (2014)
#

# Resources
# TODO (h4w5) what are some for Ubuntu?...
# https://github.com/divio/osx-bootstrap
# https://github.com/paulirish/dotfiles
# https://github.com/mathiasbynens/dotfiles/

# References
# http://www.sudo.ws/
# http://www.gnu.org/software/bash/manual/bashref.html
# http://www.shellcheck.net
# http://explainshell.com/
# Reset formatting
RESET=$(      tput sgr0)

# Foreground color
BLACK=$(      tput setaf 0)
RED=$(        tput setaf 1)
GREEN=$(      tput setaf 2)
YELLOW=$(     tput setaf 3)
BLUE=$(       tput setaf 4)
MAGENTA=$(    tput setaf 5)
CYAN=$(       tput setaf 6)
WHITE=$(      tput setaf 9)
# ORANGE=$(     tput setaf 172)
# PURPLE=$(     tput setaf 141)

# Background color
BG_BLACK=$(   tput setab 0)
BG_RED=$(     tput setab 1)
BG_GREEN=$(   tput setab 2)
BG_YELLOW=$(  tput setab 3)
BG_BLUE=$(    tput setab 4)
BG_MAGENTA=$( tput setab 5)
BG_CYAN=$(    tput setab 6)
BG_WHITE=$(   tput setab 9)
# BG_ORANGE=$(  tput setab 172)

# Style
UNDERLINE=$(  tput smul)
# NOUNDERLINE=$(tput rmul)
BOLD=$(       tput bold)
ITALIC=$(     tput sitm)
#-------------------------------------------------------------------------------
# Functions
#-------------------------------------------------------------------------------

#######################################
# ABRB
# Arguments:
#   Message
#   Attribution
# Returns:
#   None
#######################################
function quoth_the_bard () {
  local message=$1
  local attribution=$2
  echo ""
  echo "$YELLOW$message$RESET"
  echo "$PURPLE$attribution$RESET"
}

#######################################
# Upcase error message and exit script
# Arguments:
#   Error message
# Returns:
#   None
#######################################

function fie () {
  local message=$(echo $1 | tr 'a-z' 'A-Z')
  echo ""
  echo "$RED$message$RESET"
  exit
}


#######################################
# Announce our acts
# Arguments:
#   Act Number
# Returns:
#   None
#######################################
function figlet_announces () {
  clear
  local act=$1
  figlet -f ogre $act
}

#######################################
# Waits for user input
# Arguments:
#   Message
# Returns:
#   None
#######################################
function pause_awhile () {
   read -p "$* Press Enter to continue"
}

#######################################
# Mounts DMG and moves to Applications
# Arguments:
#   File name
# Returns:
#   None
#######################################
function install_dmg () {
  echo 'Hark, a dmg!'
  file_name="$1"
  MOUNTPOINT="/Volumes/MountPoint"
  IFS="
  "
  hdiutil attach -mountpoint $MOUNTPOINT "$file_name.dmg"
  app=$(find $MOUNTPOINT 2>/dev/null -maxdepth 2 -iname \*.app)
  if [[ ! -z "$app" ]]; then
    cp -a "$app" /Applications/
  fi
  echo 'Hark! A pkg!'
  pkg=$(find $MOUNTPOINT 2>/dev/null -maxdepth 2 -iname \*.pkg)
  if [[ ! -z "$pkg" ]]; then
    # PL: Need to handle harddrive names that aren't Macintosh HD
    sudo installer -package $pkg -target /
  fi
  hdiutil detach $MOUNTPOINT
}

#######################################
# Unzip Zip and move App to Applications
# Arguments:
#   File name
# Returns:
#   None
#######################################
function install_zip () {
  file_name="$1"
  echo 'Hark! A zip!'
  mkdir "$file_name"
  unzip "$file_name.zip" -d "$file_name"
  mv $file_name/*.app /Applications
}

#######################################
# Checks for the existence of a file
# Arguments:
#   File name
# Returns:
#   1 or 0
#######################################
function know_you_not_of () {
  file_name="$1"
  file_count=$(find /Applications -name "$file_name.app" | wc -l)
  if [[ $file_count -gt 0 ]]; then
    echo "$file_name is already here.";
    return 1
  else
    return 0
  fi
}

#######################################
# Downloads and installs apps from zips, dmgs, and pkgs.
# Arguments:
#   File name
#   URL
# Returns:
#   None
#######################################
function lend_me_your () {
  file_name="$1"
  url="$2"
  ext=${url: -4}
  if know_you_not_of "$file_name" ; then
    curl -L -o "$file_name$ext" $url
    # enter stage left...
    case "$ext" in
      ".dmg")  install_dmg "$file_name";;
      ".zip")  install_zip "$file_name";;
      *) echo "Not Processed";;
    esac
  fi
  # Out spot
  rm -rf "$file_name$ext"
  rm -rf "$file_name"
}

#######################################
# Allow apps to control your computer
# Arguments:
#   File name
# Returns:
#   None
#######################################
allow_control() {
  if [[ "$OSTYPE" =~ ^darwin13.*$ ]]; then
    for app; do
      APP_ID="$(osascript -e "id of app \"$app\"")"
      if [[ -n "$APP_ID" ]]; then
        sudo sqlite3 /Library/Application\ Support/com.apple.TCC/TCC.db "INSERT or REPLACE INTO access values ('kTCCServiceAccessibility', '$APP_ID', 0, 1, 0, NULL);"
      fi
    done
  else
    echo "allow_control works only on Mavericks"
  fi
}
# Capture the user's password
sudo echo "Thanks."

# Update existing `sudo` time stamp until script has finished
while true; do sudo -n true; sleep 60; kill -0 "$$" || exit; done 2>/dev/null &

# TODO (philco) does this actually work?
BELOVED_RUBY_VERSION="Ruby 1.9.3-p547"
CURRENT_STABLE_RUBY_VERSION="Ruby 2.1.2"

# TODO backport this into master and mac...
SRC_DIR=~/.wdi/installfest
SETTINGS=$SRC_DIR/settings
INSTALL_REPO=https://github.com/ga-instructors/installfest_script.git

# moving branch to a file dynamically built from rake

BRANCH=ubuntu-merge

# git for version control
sudo apt-get -y install git

# copy to clipboard
sudo apt-get -y install xclip

# Autoconf is an extensible package of M4 macros that produce shell scripts to automatically configure software source code packages.
sudo apt-get -y install autoconf

# Automake is a tool for automatically generating Makefile.in
sudo apt-get -y install automake

# general-purpose parser generator that converts an annotated context-free grammar into an LALR or GLR parser for that grammar.
sudo apt-get -y install bison

# generic library support script
sudo apt-get -y install libtool

# a YAML 1.1 parser and emitter
sudo apt-get -y install libyaml

# provides a set of functions for use by applications that allow users to edit command lines as they are typed in
sudo apt-get -y install libreadline6 libreadline6-dev

# a self-contained, serverless, zero-configuration, transactional SQL database engine.
sudo apt-get -y install sqlite3

# XML C parser and toolkit
sudo apt-get -y install libxml2-dev

# a language for transforming XML documents into other XML documents.
sudo apt-get -y install libxslt1-dev

# generates an index file of names found in source files of various programming languages.
sudo apt-get -y install exuberant-ctags

# ASCII ART!!!!
sudo apt-get -y install figlet

# visualization tool for ERDs
sudo apt-get -y install graphviz

# image resizing
sudo apt-get -y install imagemagick

# PhantomJS is a headless WebKit scriptable with a JavaScript API.
sudo apt-get -y install phantomjs

# gnome-keyring is a daemon in the session, similar to ssh-agent,
# and other applications can use it to store passwords and other
# sensitive information
# atom dependency?
sudo apt-get -y install libgnome-keyring-dev
echo "Please register for an account on github.com if you haven't already done so."

read -p "Enter your full name: "  user_name
read -p "Github Username: "       github_name
read -p "Github Email: "          github_email
# Add user's github info to gitconfig
# https://www.kernel.org/pub/software/scm/git/docs/git-config.html
git config --global user.name  $github_name
git config --global user.email $github_email

# set olors
git config --global color.ui always

git config --global color.branch.current   "green reverse"
git config --global color.branch.local     green
git config --global color.branch.remote    yellow

git config --global color.status.added     green
git config --global color.status.changed   yellow
git config --global color.status.untracked "red blink"

# set editor
git config --global core.editor "subl -w"

# default branch to push to
git config --global push.default current
# download the repo for the absolute paths
if [[ ! -d $SRC_DIR ]]; then
  echo 'Downloading Installfest repo...'
  # autoupdate bootstrap file
  git clone -b $BRANCH $INSTALL_REPO $SRC_DIR
  # hide folder
  # chflags hidden $SRC_DIR # FIXME (h4w5) doesn't work on linux
else
  # update repo
  echo 'Updating repo...'
  cd $SRC_DIR
  git pull origin $BRANCH
fi
# # our ruby version manager
# sudo apt-get -y install rbenv
# # git clone git://github.com/sstephenson/rbenv.git ~/.rbenv
# # provides an `rbenv install` command
# sudo apt-get -y install ruby-build
#
# # ruby_check=$(rbenv versions | grep $BELOVED_RUBY_VERSION)
# #
# # if [[ "$ruby_check" == *$BELOVED_RUBY_VERSION* ]]; then
# #   echo "$BELOVED_RUBY_VERSION is installed"
# # else
# #   rbenv install $BELOVED_RUBY_VERSION
# # fi
#
#
# # TODO (h4w5) must come to understand this...
# echo '\nexport PATH="$HOME/.rbenv/bin:$PATH"' >> $HOME/.bashrc
# echo '\neval "$(rbenv init -)"' >> $HOME/.bashrc
#
# source $HOME/.bashrc

git clone https://github.com/sstephenson/rbenv.git ~/.rbenv
echo 'export PATH="$HOME/.rbenv/bin:$PATH"' >> ~/.bashrc
echo 'eval "$(rbenv init -)"' >> ~/.bashrc

git clone https://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build

source ~/.bashrc
ruby_check=$(rbenv versions | grep $BELOVED_RUBY_VERSION)

if [[ "$ruby_check" == *$BELOVED_RUBY_VERSION* ]]; then
  echo "$BELOVED_RUBY_VERSION is installed"
else
  rbenv install $BELOVED_RUBY_VERSION
fi
echo "${BOLD}Ruby version is now: '`ruby -v`'...${RESET}"
echo "${BOLD}Ruby now found at: `which ruby`...${RESET}"

echo "${BOLD}Setting the global ruby as '${BELOVED_RUBY_VERSION}'...${RESET}"

rbenv global $BELOVED_RUBY_VERSION

echo "${BOLD}Ruby version is now: '`ruby -v`'...${RESET}"
echo "${BOLD}Ruby now found at: `which ruby`...${RESET}"

echo "${BOLD}Adding the rbenv binary directory to path, and prepending the .shims...${RESET}"

rbenv rehash

echo "${BOLD}Path is now:${RESET} ${PATH}"
echo "${BOLD}Ruby version is now: '`ruby -v`'...${RESET}"
echo "${BOLD}Ruby now found at: `which ruby`...${RESET}"
alias gem="/home/wdi/.rbenv/shims/gem"
# Our gems to install

# Maintains a consistent environment for ruby applications.
gem install bundler

# Acceptance test framework for web applications
gem install capybara

# handle events on file system modifications
gem install guard

# JavaScript testing
gem install jasmine

# ruby interface for Postgres
gem install pg

# alternative to the standard IRB shell
gem install pry

# live syntax highlighting for the Pry REPL
gem install pry-coolline

# full stack, Web application framework
gem install rails

# testing tool for Ruby
gem install rspec

# a DSL for quickly creating web applications in Ruby
gem install sinatra

# common Sinatra extensions
gem install sinatra-contrib

# Ruby interface to github API v3
gem install github_api

# HipChat HTTP API Wrapper
gem install hipchat

# pretty print your Ruby objects with style
gem install awesome_print

# colorizing printed text on ANSI terminals
gem install rainbow
