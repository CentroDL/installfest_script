#!/usr/bin/env bash

#-------------------------------------------------------------------------------
# Handle Command Line Options
#-------------------------------------------------------------------------------

while getopts "vf" FLAG; do
  case $FLAG in
    f ) FORCE=true;;
    v ) VERBOSE=true;;
    ? ) exit 2;;
  esac
done

#-------------------------------------------------------------------------------
# Logging
#-------------------------------------------------------------------------------

# set up logfile
LOGFOLDER="$HOME/.wdi"; mkdir -p $LOGFOLDER
LOGFILE="$LOGFOLDER/install.log"

# if we are logging verbosely
#   echo_log() & assert_that() -> stderr -> stdout -> *logfile* -> console
# else we are only logging assertions ([- n "$verbose" ] == false)
#   echo_log() & assert_that() -> stderr -> *logfile* -> stdout -> console
# this is done by:
#   a. directing echo_log() & assert_that() to stderr, via
#      {echo "" >&2}, and ...
echo_log() {
  echo "$1" >&2
}

if [ -n "$VERBOSE" ]; then
#     b. executing the script so that stdout 'tee's to logfile, via
#        {exec 1> >(tee logfile)} | {exec > >(tee logfile)}
#     c. executing the script so that stderr redirects to stdout, via
#        {exec 2>&1}
  exec > >(tee $LOGFILE); exec 2>&1
else
#     b. executing the script so that stderr 'tee's to logfile, via
#        {exec 2> >(tee logfile)}
  exec 2> >(tee $LOGFILE)
fi

echo_log
echo_log "Script execution begun: $(date)"
if [ -n "$FORCE" ]; then
  echo_log " Force option set to true: will continue script despite failed assertions."
else
  echo_log " Script will exit on failed assertions. Use -f option to force completion."
fi

if [ -n "$VERBOSE" ]; then
  echo_log " Verbose logging option set to true: will log all output, not just errors, log statements and assertions."
else
  echo_log " Script will log errors, log statements and assertions only. Use -v option to log verbosely."
fi
echo_log
#
#  _           _        _ _  __           _
# (_)_ __  ___| |_ __ _| | |/ _| ___  ___| |_
# | | '_ \/ __| __/ _` | | | |_ / _ \/ __| __|
# | | | | \__ \ || (_| | | |  _|  __/\__ \ |_
# |_|_| |_|___/\__\__,_|_|_|_|  \___||___/\__|
#
# Installation, Setup and Dotfile Creation Script
# for Students of General Assemb.ly's WDI Program

# Author: Phillip Lamplugh, GA Instructor (2014)
# Contributions: PJ Hughes, GA Instructor (2014)

# Resources
#
# https://github.com/thoughtbot/laptop
# https://github.com/toranb/ubuntu-development-machine
# https://github.com/divio/osx-bootstrap
# https://github.com/paulirish/dotfiles
# https://github.com/mathiasbynens/dotfiles/
# https://github.com/ndbroadbent/dotfiles

# References
#
# http://www.sudo.ws/
# http://www.gnu.org/software/bash/manual/bashref.html
# http://www.shellcheck.net
# http://explainshell.com/

#-------------------------------------------------------------------------------
# Set text formatting
#-------------------------------------------------------------------------------

# Reset formatting
RESET=$(      tput sgr0)

# Foreground color
BLACK=$(      tput setaf 0)
RED=$(        tput setaf 1)
GREEN=$(      tput setaf 2)
YELLOW=$(     tput setaf 3)
BLUE=$(       tput setaf 4)
MAGENTA=$(    tput setaf 5)
CYAN=$(       tput setaf 6)
WHITE=$(      tput setaf 9)
# ORANGE=$(     tput setaf 172)
# PURPLE=$(     tput setaf 141)

# Background color
BG_BLACK=$(   tput setab 0)
BG_RED=$(     tput setab 1)
BG_GREEN=$(   tput setab 2)
BG_YELLOW=$(  tput setab 3)
BG_BLUE=$(    tput setab 4)
BG_MAGENTA=$( tput setab 5)
BG_CYAN=$(    tput setab 6)
BG_WHITE=$(   tput setab 9)
# BG_ORANGE=$(  tput setab 172)

# Style
UNDERLINE=$(  tput smul)
NOUNDERLINE=$(tput rmul)
BOLD=$(       tput bold)
ITALIC=$(     tput sitm)

# set FORCE (do not quit on error) to true if it is not loaded, as a default
: ${FORCE=true} # TODO (h4w5) since we are testing for null, this will always happen
                # switch to true/false

echo_log() {
  echo "$1" >&2
}

# ex: assert_that "`gem` is installed" "gem"
# ex: assert_that "`gem` is shimmed by rbenv" "which gem" "$HOME/.rbenv/shims/gem"
# ex: assert_that "pg gem is installed" "gem list pg -i" "true"

# log the success or failure of the file...
# if only two arguments, then success is running second arg without an error
# if three, then success is the above, and when the output of running the second is equal to the third
assert_that() {
  # test for a simple error by evaling the second argument, and redirecting only
  # STDERR to a variable named ERR
  ERR=$( (eval "$2") 2>&1 >/dev/null )
  OUT=$( (eval "$2") 2>/dev/null )

  if [ -n "$ERR" ]; then # if ERR is not null, then...
    # echo failure to STDERR & STDOUT
    echo_log "${RED}$1: failure! Error: ${ERR}${RESET}"
    [ -n "$FORCE" ] || exit 1; # exit on failure if not 'forcing'
  elif [ -n "$3" ]; then # else, if there is a third argument...
    if [ "$OUT" == "$3" ]; then # and they equal
      # echo success to STDERR & STDOUT
      echo_log "${GREEN}$1...${RESET}"
    else
      # echo failure to STDERR & STDOUT if second and third arguments do not match
      echo_log "${RED}$1: failure! '$OUT' does not equal '$3'.${RESET}"
      [ -n "$FORCE" ] || exit 1; # exit on failure if not 'forcing'
    fi
  else
    # echo success to STDERR & STDOUT
    echo_log "${GREEN}$1...${RESET}"
  fi
}

# ex: assert_package_installed "git"
# ex: packagelist=( libssl-dev; libcurl4-openssl-dev; git; git-core ); assert_package_installed ${packagelist[@]}

# only works when packages share a name across OSs, otherwise easiest to write
# two assertions...
assert_package_installed() {
  for package in "$@"; do
    if [ "$OSTYPE" == "darwin" ]; then
      assert_that "${package} package is installed" "brew ls --versions ${package}" "${package}"
    elif [ "$OSTYPE" == "linux-gnu" ]; then
      assert_that "${package} package is installed" "dpkg -s ${package}"
    else
      echo_log "${RED}OS Type unknown in assertions...${RESET}" && exit 1;
    fi
  done
}
BELOVED_RUBY_VERSION="2.1.2"
CURRENT_STABLE_RUBY_VERSION="2.1.2"

# TODO backport this into master and mac...
SRC_DIR=~/.wdi/installfest
SETTINGS=$SRC_DIR/settings
INSTALL_REPO=https://github.com/ga-instructors/installfest_script.git

# Standard Bash Variables
# `OSTYPE` A string describing the operating system Bash is running on.
# `MACHTYPE` system type in cpu-company-system
# `SECONDS` number of seconds since the shell was started.

# This refers to the branch of our repo that we are using (for cloning).
BRANCH=pj_working

# capture the user's password
sudo -p "Enter your computer's password so that we can make the necessary changes: " echo "Thank you."

#-------------------------------------------------------------------------------
# Check for software updates
#-------------------------------------------------------------------------------

sudo apt-get -y update
sudo apt-get -y upgrade
sudo apt-get -y dist-upgrade
packagelist=(
  # Autoconf is an extensible package of M4 macros that produce shell scripts to automatically configure software source code packages.
  autoconf

  # Automake is a tool for automatically generating Makefile.in
  automake

  # general-purpose parser generator that converts an annotated context-free grammar into an LALR or GLR parser for that grammar.
  bison

  # generic library support script
  libtool

  # a YAML 1.1 parser and emitter
  libyaml-dev

  # provides a set of functions for use by applications that allow users to edit command lines as they are typed in
  libreadline6 libreadline6-dev libreadline-dev

  # XML C parser and toolkit
  libxml2-dev

  # a language for transforming XML documents into other XML documents.
  libxslt1-dev

  # gnome-keyring is a daemon in the session, similar to ssh-agent,
  # and other applications can use it to store passwords and other
  # sensitive information
  # atom dependency?
  libgnome-keyring-dev

  # OpenSSL implementation of SSL
  libssl-dev
  libcurl4-openssl-dev

  # version control
  git
  git-core

  # copy to clipboard
  xclip

  # command line tool for transferring data with URL syntax
  curl

  # This software provides an abstraction of the used apt repositories.
  python-software-properties

  # a reference for all the packages needed to compile a debian package
  # generally includes the gcc/g++ compilers an libraries and some other utils
  build-essential

  # library implementing the deflate compression method found in gzip and PKZIP
  zlib1g-dev

  # generates an index file of names found in source files of various programming languages.
  exuberant-ctags

  # Header files and static library for compiling C programs to link with the
  # libpq library in order to communicate with a PostgreSQL database backend.
  libpq-dev
  # or try
  # gem install pg  --   --with-pg-lib=/usr/lib

  # self-contained, serverless, transactional SQL database engine.
  sqlite3
  libsqlite3-dev

  # ASCII ART!!!!
  figlet

  # visualization tool for ERDs
  graphviz

  # image resizing
  imagemagick

  # headless WebKit scriptable with a JavaScript API.
  phantomjs
)

sudo apt-get -y install ${packagelist[@]}

assert_package_installed ${packagelist[@]}
echo "Please register for an account on github.com if you haven't already done so."

read -p "Enter your full name: "  user_name
read -p "Github Username: "       github_name
read -p "Github Email: "          github_email

# SSH Keygen
ssh-keygen -t rsa -C $github_email
ssh-add id_rsa

# Copy SSH key to the clipboard
cat ~/.ssh/id_rsa.pub | xclip -selection clipboard

echo "We just copied your SSH key to the clipboard."
echo "Now we're going to visit GitHub to add the SSH key"

echo "Do the following in your browser: "
echo '- Click "SSH Keys" in the left sidebar'
echo '- Click "Add SSH key"'
echo '- Set the Title to WDI Installfest'
echo '- Paste your key into the "Key" field'
echo '- Click "Add key"'
echo '- Confirm the action by entering your GitHub password'

read -p "Press Enter. We'll be here until you get back from Github. Press Enter to continue."

# Open in default browser as a new process
echo "Firefox may print an error to the terminal. DON'T WORRY!" # directing output to /dev/null to supress error
xdg-open https://github.com/settings/ssh 2>/dev/null

read -p "Ok. Ready to Continue? Press Enter."

# TODO (h4w5) add assertion around ... "ssh -T git@github.com"
# Add user's github info to gitconfig
# https://www.kernel.org/pub/software/scm/git/docs/git-config.html
git config --global user.name  $github_name
git config --global user.email $github_email

# set colors
git config --global color.ui always

git config --global color.branch.current   "green reverse"
git config --global color.branch.local     green
git config --global color.branch.remote    yellow

git config --global color.status.added     green
git config --global color.status.changed   yellow
git config --global color.status.untracked "red blink"

# set editor
git config --global core.editor "subl -w"

# default branch to push to
git config --global push.default current
