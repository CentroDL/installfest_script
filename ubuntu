#!/usr/bin/env bash

#-------------------------------------------------------------------------------
# Handle Command Line Options
#-------------------------------------------------------------------------------

while getopts "vf" FLAG; do
  case $FLAG in
    f ) FORCE=true;;
    v ) VERBOSE=true;;
    ? ) exit 2;;
  esac
done

#-------------------------------------------------------------------------------
# Logging
#-------------------------------------------------------------------------------

# set up logfile
LOGFOLDER="$HOME/.wdi"; mkdir -p $LOGFOLDER
LOGFILE="$LOGFOLDER/install.log"

# if we are logging verbosely
#   echo_log() & assert_that() -> stderr -> stdout -> *logfile* -> console
# else we are only logging assertions ([- n "$verbose" ] == false)
#   echo_log() & assert_that() -> stderr -> *logfile* -> stdout -> console
# this is done by:
#   a. directing echo_log() & assert_that() to stderr, via
#      {echo "" >&2}, and ...
echo_log() {
  echo "$1" >&2
}

if [ -n "$VERBOSE" ]; then
#     b. executing the script so that stdout 'tee's to logfile, via
#        {exec 1> >(tee logfile)} | {exec > >(tee logfile)}
#     c. executing the script so that stderr redirects to stdout, via
#        {exec 2>&1}
  exec > >(tee $LOGFILE); exec 2>&1
else
#     b. executing the script so that stderr 'tee's to logfile, via
#        {exec 2> >(tee logfile)}
  exec 2> >(tee $LOGFILE)
fi

echo_log
echo_log "Script execution begun: $(date)"
if [ -n "$FORCE" ]; then
  echo_log " Force option set to true: will continue script despite failed assertions."
else
  echo_log " Script will exit on failed assertions. Use -f option to force completion."
fi

if [ -n "$VERBOSE" ]; then
  echo_log " Verbose logging option set to true: will log all output, not just errors, log statements and assertions."
else
  echo_log " Script will log errors, log statements and assertions only. Use -v option to log verbosely."
fi
echo_log
#
#  _           _        _ _  __           _
# (_)_ __  ___| |_ __ _| | |/ _| ___  ___| |_
# | | '_ \/ __| __/ _` | | | |_ / _ \/ __| __|
# | | | | \__ \ || (_| | | |  _|  __/\__ \ |_
# |_|_| |_|___/\__\__,_|_|_|_|  \___||___/\__|
#
# Installation, Setup and Dotfile Creation Script
# for Students of General Assemb.ly's WDI Program

# Author: Phillip Lamplugh, GA Instructor (2014)
# Contributions: PJ Hughes, GA Instructor (2014)

# Resources
#
# https://github.com/thoughtbot/laptop
# https://github.com/toranb/ubuntu-development-machine
# https://github.com/divio/osx-bootstrap
# https://github.com/paulirish/dotfiles
# https://github.com/mathiasbynens/dotfiles/
# https://github.com/ndbroadbent/dotfiles

# References
#
# http://www.sudo.ws/
# http://www.gnu.org/software/bash/manual/bashref.html
# http://www.shellcheck.net
# http://explainshell.com/

#-------------------------------------------------------------------------------
# Set text formatting
#-------------------------------------------------------------------------------

# Reset formatting
RESET=$(      tput sgr0)

# Foreground color
BLACK=$(      tput setaf 0)
RED=$(        tput setaf 1)
GREEN=$(      tput setaf 2)
YELLOW=$(     tput setaf 3)
BLUE=$(       tput setaf 4)
MAGENTA=$(    tput setaf 5)
CYAN=$(       tput setaf 6)
WHITE=$(      tput setaf 9)
# ORANGE=$(     tput setaf 172)
# PURPLE=$(     tput setaf 141)

# Background color
BG_BLACK=$(   tput setab 0)
BG_RED=$(     tput setab 1)
BG_GREEN=$(   tput setab 2)
BG_YELLOW=$(  tput setab 3)
BG_BLUE=$(    tput setab 4)
BG_MAGENTA=$( tput setab 5)
BG_CYAN=$(    tput setab 6)
BG_WHITE=$(   tput setab 9)
# BG_ORANGE=$(  tput setab 172)

# Style
UNDERLINE=$(  tput smul)
NOUNDERLINE=$(tput rmul)
BOLD=$(       tput bold)
ITALIC=$(     tput sitm)

# set FORCE (do not quit on error) to true if it is not loaded, as a default
: ${FORCE=true}

echo_log() {
  echo "$1" >&2
}

# ex: assert_that "`gem` is installed" "gem"
# ex: assert_that "`gem` is shimmed by rbenv" "which gem" "$HOME/.rbenv/shims/gem"
# ex: assert_that "pg gem is installed" "gem list pg -i" "true"

# log the success or failure of the file...
# if only two arguments, then success is running second arg without an error
# if three, then success is the above, and when the output of running the second is equal to the third
assert_that() {
  # test for a simple error by evaling the second argument, and redirecting only
  # STDERR to a variable named ERR
  ERR=$( (eval "$2") 2>&1 >/dev/null ) && { OUT=$(eval "$2"); }

  if [ -n "$ERR" ]; then # if ERR is not null, then...
    # echo failure to STDERR & STDOUT
    echo_log "${RED}$1: failure! Error: ${ERR}${RESET}"
    [ -n "$FORCE" ] || exit 1; # exit on failure if not 'forcing'
  elif [ -n "$3" ]; then # else, if there is a third argument...
    echo $OUT
    if [ "$OUT" == "$3" ]; then # and they equal
      # echo success to STDERR & STDOUT
      echo_log "${GREEN}$1...${RESET}"
    else
      # echo failure to STDERR & STDOUT if second and third arguments do not match
      echo_log "${RED}$1: failure! '$OUT' does not equal '$3'.${RESET}"
      [ -n "$FORCE" ] || exit 1; # exit on failure if not 'forcing'
    fi
  else
    # echo success to STDERR & STDOUT
    echo_log "${GREEN}$1...${RESET}"
  fi
}

# ex: assert_package_installed "git"
# ex: packagelist=( libssl-dev; libcurl4-openssl-dev; git; git-core ); assert_package_installed ${packagelist[@]}

# only works when packages share a name across OSs, otherwise easiest to write
# two assertions...
assert_package_installed() {
  for package in "$@"; do
    if [ "$OSTYPE" == "darwin" ]; then
      assert_that "'${package}' package is installed" "brew ls --versions ${package}" "${package}"
    elif [ "$OSTYPE" == "linux-gnu" ]; then
      assert_that "'${package}' package is installed" "dpkg -s ${package}"
    else
      echo_log "${RED}OS Type unknown in assertions...${RESET}" && exit 1;
    fi
  done
}
BELOVED_RUBY_VERSION="2.1.2"
CURRENT_STABLE_RUBY_VERSION="2.1.2"

# TODO backport this into master and mac...
SRC_DIR=~/.wdi/installfest
SETTINGS=$SRC_DIR/settings
INSTALL_REPO=https://github.com/ga-instructors/installfest_script.git

# This refers to the branch of our repo that we are using (for cloning).
BRANCH=pj_working
# Capture the user's password
sudo echo "Thanks."

# Update existing `sudo` time stamp until script has finished
while true; do sudo -n true; sleep 60; kill -0 "$$" || exit; done 2>/dev/null &

# TODO (phlco) does this actually work?

#-------------------------------------------------------------------------------
# Check for software updates
#-------------------------------------------------------------------------------

sudo apt-get -y update
sudo apt-get -y upgrade
sudo apt-get -y dist-upgrade
packagelist=(
  # Autoconf is an extensible package of M4 macros that produce shell scripts to automatically configure software source code packages.
  autoconf

  # Automake is a tool for automatically generating Makefile.in
  automake

  # general-purpose parser generator that converts an annotated context-free grammar into an LALR or GLR parser for that grammar.
  bison

  # generic library support script
  libtool

  # a YAML 1.1 parser and emitter
  libyaml-dev

  # provides a set of functions for use by applications that allow users to edit command lines as they are typed in
  libreadline6 libreadline6-dev libreadline-dev

  # XML C parser and toolkit
  libxml2-dev

  # a language for transforming XML documents into other XML documents.
  libxslt1-dev

  # gnome-keyring is a daemon in the session, similar to ssh-agent,
  # and other applications can use it to store passwords and other
  # sensitive information
  # atom dependency?
  libgnome-keyring-dev

  # OpenSSL implementation of SSL
  libssl-dev
  libcurl4-openssl-dev

  # version control
  git
  git-core

  # copy to clipboard
  xclip

  # command line tool for transferring data with URL syntax
  curl

  # This software provides an abstraction of the used apt repositories.
  python-software-properties

  # a reference for all the packages needed to compile a debian package
  # generally includes the gcc/g++ compilers an libraries and some other utils
  build-essential

  # library implementing the deflate compression method found in gzip and PKZIP
  zlib1g-dev

  # generates an index file of names found in source files of various programming languages.
  exuberant-ctags

  # Header files and static library for compiling C programs to link with the
  # libpq library in order to communicate with a PostgreSQL database backend.
  libpq-dev
  # or try
  # gem install pg  --   --with-pg-lib=/usr/lib

  # self-contained, serverless, transactional SQL database engine.
  sqlite3
  libsqlite3-dev

  # ASCII ART!!!!
  figlet

  # visualization tool for ERDs
  graphviz

  # image resizing
  imagemagick

  # headless WebKit scriptable with a JavaScript API.
  phantomjs
)

sudo apt-get -y install ${packagelist[@]}
echo "Please register for an account on github.com if you haven't already done so."

read -p "Enter your full name: "  user_name
read -p "Github Username: "       github_name
read -p "Github Email: "          github_email

# SSH Keygen
ssh-keygen -t rsa -C $github_email
ssh-add id_rsa

# Copy SSH key to the clipboard
cat ~/.ssh/id_rsa.pub | xclip -selection clipboard

echo "We just copied your SSH key to the clipboard."
echo "Now we're going to visit GitHub to add the SSH key"

echo "Do the following in your browser: "
echo '- Click "SSH Keys" in the left sidebar'
echo '- Click "Add SSH key"'
echo '- Set the Title to WDI Installfest'
echo '- Paste your key into the "Key" field'
echo '- Click "Add key"'
echo '- Confirm the action by entering your GitHub password'

read -p "Press Enter. We'll be here until you get back from Github. Press Enter to continue."

# Open in default browser as a new process
echo "Firefox may print an error to the terminal. DON'T WORRY!" # directing output to /dev/null to supress error
xdg-open https://github.com/settings/ssh 2>/dev/null

read -p "Ok. Ready to Continue? Press Enter."

# TODO (h4w5) add assertion around ... "ssh -T git@github.com"
# Add user's github info to gitconfig
# https://www.kernel.org/pub/software/scm/git/docs/git-config.html
git config --global user.name  $github_name
git config --global user.email $github_email

# set colors
git config --global color.ui always

git config --global color.branch.current   "green reverse"
git config --global color.branch.local     green
git config --global color.branch.remote    yellow

git config --global color.status.added     green
git config --global color.status.changed   yellow
git config --global color.status.untracked "red blink"

# set editor
git config --global core.editor "subl -w"

# default branch to push to
git config --global push.default current
# download the repo for the absolute paths
if [[ ! -d $SRC_DIR ]]; then
  echo 'Downloading Installfest repo...'
  # autoupdate bootstrap file
  git clone -b $BRANCH $INSTALL_REPO $SRC_DIR
  # hide folder
  # chflags hidden $SRC_DIR # FIXME (h4w5) doesn't work on linux
else
  # update repo
  echo 'Updating repo...'
  cd $SRC_DIR
  git pull origin $BRANCH
fi
# uninstall rvm, so that we can use rbenv
# http://stackoverflow.com/questions/3950260/howto-uninstall-rvm
if hash rvm 2>/dev/null || [ -d ~/.rvm ]; then
  yes | rvm implode
  rm -rf ~/.rvm
fi

assert_that "RVM has been removed or was not installed" "command -v rvm" ""
# Our ruby version manager

# rbenv
git clone https://github.com/sstephenson/rbenv.git ~/.rbenv

export PATH="$HOME/.rbenv/bin:$PATH"
eval "$(rbenv init -)"

assert_that "Rbenv is installed" "rbenv"

# Specify default gems in ~/.rbenv/default-gems
git clone https://github.com/sstephenson/rbenv-default-gems.git ~/.rbenv/plugins/rbenv-default-gems

# automatically runs rbenv rehash every time you install or uninstall a gem
git clone https://github.com/sstephenson/rbenv-gem-rehash.git ~/.rbenv/plugins/rbenv-gem-rehash

# Provides an rbenv install command to compile and install different versions of Ruby
git clone https://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build

assert_that "Rbenv's ruby-build plugin is installed" "rbenv install"

# Our gems to install
# skip documentation
echo "gem: --no-ri --no-rdoc" > ~/.gemrc

# TODO (phlco) replace ~/.rbenv with $RBENV_ROOT
touch ~/.rbenv/default-gems

gemlist=(
  bundler         # Maintains a consistent environment for ruby applications.
  capybara        # Acceptance test framework for web applications
  guard           # handle events on file system modifications
  jasmine         # JavaScript testing
  pg              # ruby interface for Postgres
  pry             # alternative to the standard IRB shell
  pry-coolline    # live syntax highlighting for the Pry REPL
  rails           # full stack, Web application framework
  rspec           # testing tool for Ruby
  sinatra         # a DSL for quickly creating web applications in Ruby
  sinatra-contrib # common Sinatra extensions
  github_api      # Ruby interface to github API v3
  hipchat         # HipChat HTTP API Wrapper
  awesome_print   # pretty print your Ruby objects with style
  rainbow         # colorizing printed text on ANSI terminals
)

for gem in ${gemlist[@]}; do
  echo "${gem}" >> ~/.rbenv/default-gems
done

# For testing and simplicity with Ubuntu, add these to the .bashrc until it's
# overwritten...
echo 'export PATH="$HOME/.rbenv/bin:$PATH"' >> ~/.bashrc
echo 'eval "$(rbenv init -)"' >> ~/.bashrc

source ~/.bashrc
ruby_check=$(rbenv versions | grep $BELOVED_RUBY_VERSION)

if [[ "$ruby_check" == *$BELOVED_RUBY_VERSION* ]]; then
  echo "$BELOVED_RUBY_VERSION is installed"
else
  rbenv install $BELOVED_RUBY_VERSION
fi

# rbenv rehash
# assert_that "Ruby is installed" "which ruby" "~/.rbenv/bin"
# echo "${BOLD}Ruby version is now: '`ruby -v`'...${RESET}"
# echo "${BOLD}Ruby now found at: `which ruby`...${RESET}"
#
# echo "${BOLD}Setting the global ruby as '${BELOVED_RUBY_VERSION}'...${RESET}"

rbenv global $BELOVED_RUBY_VERSION

# echo "${BOLD}Ruby version is now: '`ruby -v`'...${RESET}"
# echo "${BOLD}Ruby now found at: `which ruby`...${RESET}"
#
# echo "${BOLD}Adding the rbenv binary directory to path, and prepending the .shims...${RESET}"

# rbenv rehash # happens at end of eval above I believe (h4w5)

# echo "${BOLD}Path is now:${RESET} ${PATH}"
# echo "${BOLD}Ruby version is now: '`ruby -v`'...${RESET}"
# echo "${BOLD}Ruby now found at: `which ruby`...${RESET}"

# echo "${BOLD}Path is now:${RESET} ${PATH}"
# echo "${BOLD}Ruby version is now: '`ruby -v`'...${RESET}"
# echo "${BOLD}Ruby now found at: `which ruby`...${RESET}"
# echo "${BOLD}Gem environment is now:${RESET}"
# gem env

# export PATH="$HOME/.rbenv/bin:$PATH"
# eval "$(rbenv init -)"

assert_that "Ruby version is now '${BELOVED_RUBY_VERSION}'" "ruby -v" "${BELOVED_RUBY_VERSION}"
# Event-driven I/O server-side JavaScript environment based on V8
sudo apt-get -y install nodejs

# Node package manager
sudo apt-get -y install npm

# For programs that still depend on calling the "node" binary, run:
sudo apt-get -y install nodejs-legacy
# Google Chrome.........The Browser
# HipChat...............The Chat Client
# Sublime Text 2........The Text Editor

# chrome
wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add -
sudo sh -c 'echo "deb http://dl.google.com/linux/chrome/deb/ stable main" >> /etc/apt/sources.list.d/google.list'
sudo apt-get -y update
sudo apt-get -y install google-chrome-stable

# hipchat
echo "deb http://downloads.hipchat.com/linux/apt stable main" > /etc/apt/sources.list.d/atlassian-hipchat.list
wget -O - https://www.hipchat.com/keys/hipchat-linux.key | apt-key add -
sudo apt-get -y update
sudo apt-get -y install hipchat

# sublime
sudo add-apt-repository -y ppa:webupd8team/sublime-text-2
sudo apt-get -y update
sudo apt-get -y install sublime-text

# zsh
sudo apt-get -y install zsh

# flux
sudo add-apt-repository -y ppa:kilian/f.lux
sudo apt-get -y update
sudo apt-get -y install fluxgui

# hub
# http://eoinoc.net/install-hub-github-linux-mint/
curl http://defunkt.io/hub/standalone -Lo ~/usr/bin/hub
chmod 755 ~/usr/bin/hub

# vim
sudo apt-get -y install vim
# atom
# Requires 64-bit
# ensure that gyp uses Python 2
sudo npm config set python /usr/bin/python2 -g
git clone https://github.com/atom/atom
cd atom
# TMPDIR=~/.wdi/tmp
# Creates application at $TMPDIR/atom-build/Atom
# TODO (phlco) move to /usr/bin
script/build
# Installs command to /usr/local/bin/atom
sudo script/grunt install
# Generates a .deb package at $TMPDIR/atom-build
script/grunt mkdeb
# TODO (phlco) command line tool for atom?
# sudo dpkg -i $TMPDIR/atom-build/Atom.deb
# open source object-relational database management system
# https://www.digitalocean.com/community/articles/how-to-install-and-use-postgresql-on-ubuntu-12-04
# TODO phlco set up user
# https://help.ubuntu.com/community/PostgreSQL
# sudo apt-get -y install postgresql-xc-client
# sudo apt-get -y install postgresql-client
# sudo apt-get -y install postgresql
# sudo apt-get -y install postgresql-contrib
# sudo apt-get -y install pg_ctl # initialize stop/start posgres
sudo apt-get -y install postgresql
sudo apt-get -y install postgresql-contrib
sudo apt-get -y install libpq-dev # should fix issue with installing pg gem

sudo -u postgres createuser --superuser $USER
# TODO phlco. taking out?
# sudo -u postgres psql
# create a history?
touch ~/.psql_history

createdb $USER
# Install Vim Plugin Manager
git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim

# Vimrc is copied over from dotfiles
# The Z shell (zsh) is a Unix shell that can be used as an interactive login
# shell and as a powerful command interpreter for shell scripting. Zsh can be
# thought of as an extended Bourne shell with a large number of improvements,
# including some features of bash, ksh, and tcsh.
# This script installs zsh, oh-my-zsh, an open source, community-driven framework
# for managing your ZSH configuration.

# Install zsh
git clone git://zsh.git.sf.net/gitroot/zsh/zsh
cp ~/.zshrc ~/.zshrc.orig

# Install oh-my-zsh
git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh
cp $SRC_DIR/settings/dotfiles/zshrc ~/.zshrc

# Syntax Highlighting
git clone git://github.com/zsh-users/zsh-syntax-highlighting.git ~/.oh-my-zsh/custom/plugins

# Set as default
# chsh -s /bin/zsh

# Resources
# https://github.com/robbyrussell/oh-my-zsh
# http://www.stevendobbelaere.be/installing-and-configuring-the-oh-my-zsh-shell/
# Heroku command-line tooling for working with the Heroku platform

# http://eoinoc.net/install-hub-github-linux-mint/
wget -qO- https://toolbelt.heroku.com/install-ubuntu.sh | sh

# https://devcenter.heroku.com/articles/keys
echo "Heroku is a cloud platform as a service (PaaS) supporting several"
echo "programming languages."

echo "If you don’t already use SSH, you’ll need to create a public/private key"
echo "pair to deploy code to Heroku. This keypair is used for the strong"
echo "cryptography and that uniquely identifies you as a developer when pushing"
echo "code changes."

ssh-keygen -t rsa

echo "The first time you run the heroku command, you’ll be prompted for your "
echo "credentials. Your public key will then be automatically uploaded to"
echo "Heroku. This will allow you to deploy code to all of your apps."
echo "Please enter your email"

heroku keys:add
# Don't ask questions
export DEBIAN_FRONTEND=noninteractive
sudo apt-get install -y mailutils
# email subject
SUBJECT="Log Report"
# Email To ?
EMAIL="philco@ga.co"
# Email text/message
EMAILMESSAGE="/tmp/emailmessage.txt"
cat "$HOME/.wdi/install.log"> $EMAILMESSAGE
# send an email using /bin/mail
mail -s "$SUBJECT" "$EMAIL" < $EMAILMESSAGE

# FIXME (phlco) this reports broken pipe in ubuntu
# run exec $SHELL at end?
# atom . doesn't work.
# subl . works
