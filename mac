#!/usr/bin/env bash

#-------------------------------------------------------------------------------
# Handle Command Line Options
#-------------------------------------------------------------------------------

while getopts "vf" FLAG; do
  case $FLAG in
    f ) FORCE=true;;
    v ) VERBOSE=true;;
    ? ) exit 2;;
  esac
done

#-------------------------------------------------------------------------------
# Logging
#-------------------------------------------------------------------------------

# set up logfile
LOGFOLDER="$HOME/.wdi"; mkdir -p $LOGFOLDER
LOGFILE="$LOGFOLDER/install.log"

# if we are logging verbosely
#   echo_log() & assert_that() -> stderr -> stdout -> *logfile* -> console
# else we are only logging assertions ([- n "$verbose" ] == false)
#   echo_log() & assert_that() -> stderr -> *logfile* -> stdout -> console
# this is done by:
#   a. directing echo_log() & assert_that() to stderr, via
#      {echo "" >&2}, and ...
echo_log() {
  echo "$1" >&2
}

if [ -n "$VERBOSE" ]; then
#     b. executing the script so that stdout 'tee's to logfile, via
#        {exec 1> >(tee logfile)} | {exec > >(tee logfile)}
#     c. executing the script so that stderr redirects to stdout, via
#        {exec 2>&1}
  exec > >(tee $LOGFILE); exec 2>&1
else
#     b. executing the script so that stderr 'tee's to logfile, via
#        {exec 2> >(tee logfile)}
  exec 2> >(tee $LOGFILE)
fi

echo_log
echo_log "Script execution begun: $(date)"
if [ -n "$FORCE" ]; then
  echo_log " Force option set to true: will continue script despite failed assertions."
else
  echo_log " Script will exit on failed assertions. Use -f option to force completion."
fi

if [ -n "$VERBOSE" ]; then
  echo_log " Verbose logging option set to true: will log all output, not just errors, log statements and assertions."
else
  echo_log " Script will log errors, log statements and assertions only. Use -v option to log verbosely."
fi
echo_log
#
#  _           _        _ _  __           _
# (_)_ __  ___| |_ __ _| | |/ _| ___  ___| |_
# | | '_ \/ __| __/ _` | | | |_ / _ \/ __| __|
# | | | | \__ \ || (_| | | |  _|  __/\__ \ |_
# |_|_| |_|___/\__\__,_|_|_|_|  \___||___/\__|
#
# Installation, Setup and Dotfile Creation Script
# for Students of General Assemb.ly's WDI Program

# Author: Phillip Lamplugh, GA Instructor (2014)
# Contributions: PJ Hughes, GA Instructor (2014)

# Resources
#
# https://github.com/thoughtbot/laptop
# https://github.com/toranb/ubuntu-development-machine
# https://github.com/divio/osx-bootstrap
# https://github.com/paulirish/dotfiles
# https://github.com/mathiasbynens/dotfiles/
# https://github.com/ndbroadbent/dotfiles

# References
#
# http://www.sudo.ws/
# http://www.gnu.org/software/bash/manual/bashref.html
# http://www.shellcheck.net
# http://explainshell.com/

#-------------------------------------------------------------------------------
# Set text formatting
#-------------------------------------------------------------------------------

# Reset formatting
RESET=$(      tput sgr0)

# Foreground color
BLACK=$(      tput setaf 0)
RED=$(        tput setaf 1)
GREEN=$(      tput setaf 2)
YELLOW=$(     tput setaf 3)
BLUE=$(       tput setaf 4)
MAGENTA=$(    tput setaf 5)
CYAN=$(       tput setaf 6)
WHITE=$(      tput setaf 9)
# ORANGE=$(     tput setaf 172)
# PURPLE=$(     tput setaf 141)

# Background color
BG_BLACK=$(   tput setab 0)
BG_RED=$(     tput setab 1)
BG_GREEN=$(   tput setab 2)
BG_YELLOW=$(  tput setab 3)
BG_BLUE=$(    tput setab 4)
BG_MAGENTA=$( tput setab 5)
BG_CYAN=$(    tput setab 6)
BG_WHITE=$(   tput setab 9)
# BG_ORANGE=$(  tput setab 172)

# Style
UNDERLINE=$(  tput smul)
NOUNDERLINE=$(tput rmul)
BOLD=$(       tput bold)
ITALIC=$(     tput sitm)

#-------------------------------------------------------------------------------
# Functions
#-------------------------------------------------------------------------------

# Allow apps to control your computer
allow_control() {
  if [[ "$OSTYPE" =~ ^darwin13.*$ ]]; then
    for app; do
      APP_ID="$(osascript -e "id of app \"$app\"")"
      if [[ -n "$APP_ID" ]]; then
        sudo sqlite3 /Library/Application\ Support/com.apple.TCC/TCC.db "INSERT or REPLACE INTO access values ('kTCCServiceAccessibility', '$APP_ID', 0, 1, 0, NULL);"
      fi
    done
  else
    echo "allow_control works only on Mavericks"
  fi
}

# set FORCE (do not quit on error) to true if it is not loaded, as a default
: ${FORCE=true} # TODO (h4w5) since we are testing for null, this will always happen
                # switch to true/false

echo_log() {
  echo "$1" >&2
}

# ex: assert_that "`gem` is installed" "gem"
# ex: assert_that "`gem` is shimmed by rbenv" "which gem" "$HOME/.rbenv/shims/gem"
# ex: assert_that "pg gem is installed" "gem list pg -i" "true"

# log the success or failure of the file...
# if only two arguments, then success is running second arg without an error
# if three, then success is the above, and when the output of running the second is equal to the third
assert_that() {
  # test for a simple error by evaling the second argument, and redirecting only
  # STDERR to a variable named ERR
  ERR=$( (eval "$2") 2>&1 >/dev/null )
  OUT=$( (eval "$2") 2>/dev/null )

  if [ -n "$ERR" ]; then # if ERR is not null, then...
    # echo failure to STDERR & STDOUT
    echo_log "${RED}$1: failure! Error: ${ERR}${RESET}"
    [ -n "$FORCE" ] || exit 1; # exit on failure if not 'forcing'
  elif [ -n "$3" ]; then # else, if there is a third argument...
    if [ "$OUT" == "$3" ]; then # and they equal
      # echo success to STDERR & STDOUT
      echo_log "${GREEN}$1...${RESET}"
    else
      # echo failure to STDERR & STDOUT if second and third arguments do not match
      echo_log "${RED}$1: failure! '$OUT' does not equal '$3'.${RESET}"
      [ -n "$FORCE" ] || exit 1; # exit on failure if not 'forcing'
    fi
  else
    # echo success to STDERR & STDOUT
    echo_log "${GREEN}$1...${RESET}"
  fi
}

# ex: assert_package_installed "git"
# ex: packagelist=( libssl-dev; libcurl4-openssl-dev; git; git-core ); assert_package_installed ${packagelist[@]}

# only works when packages share a name across OSs, otherwise easiest to write
# two assertions...
assert_package_installed() {
  for package in "$@"; do
    if [ "$OSTYPE" == "darwin" ]; then
      assert_that "${package} package is installed" "brew ls --versions ${package}" "${package}"
    elif [ "$OSTYPE" == "linux-gnu" ]; then
      assert_that "${package} package is installed" "dpkg -s ${package}"
    else
      echo_log "${RED}OS Type unknown in assertions...${RESET}" && exit 1;
    fi
  done
}
BELOVED_RUBY_VERSION="2.1.2"
CURRENT_STABLE_RUBY_VERSION="2.1.2"

# TODO backport this into master and mac...
SRC_DIR=~/.wdi/installfest
SETTINGS=$SRC_DIR/settings
INSTALL_REPO=https://github.com/ga-instructors/installfest_script.git

# Standard Bash Variables
# `OSTYPE` A string describing the operating system Bash is running on.
# `MACHTYPE` system type in cpu-company-system
# `SECONDS` number of seconds since the shell was started.
MINIMUM_OS="10.7.0"

# This refers to the branch of our repo that we are using (for cloning).
BRANCH=pj_working
# Capture the user's password
sudo -p "Please enter your computer's password so that we can make the necessary changes: " echo "Thanks."

# Update existing `sudo` time stamp until script has finished
while true; do sudo -v true; sleep 60; kill -0 "$$" || exit; done 2>/dev/null &
# uninstall rvm, so that we can use rbenv
# http://stackoverflow.com/questions/3950260/howto-uninstall-rvm
if hash rvm 2>/dev/null || [ -d ~/.rvm ]; then
  yes | rvm implode
  rm -rf ~/.rvm
fi

assert_that "RVM has been removed or was not installed" "command -v rvm" ""
# Because we're going to use rbenv and homebrew we need to remove RVM and MacPorts
# This script checks for and removes previous installs of macports and RVM

# Uninstall Macports
# http://guide.macports.org/chunked/installing.macports.uninstalling.html
if hash port 2>/dev/null || [[ $(find /opt/local -iname macports 2>/dev/null) ]]; then
  echo "Removing MacPorts"
    macports=$(find /opt/local -iname macports)
    for f in $macports; do
      rm -rf $f
    done
  # carthago delenda est
  sudo port -fp uninstall installed
  sudo rm -rf \
    /opt/local \
    /Applications/DarwinPorts \
    /Applications/MacPorts \
    /Library/LaunchDaemons/org.macports.* \
    /Library/Receipts/DarwinPorts*.pkg \
    /Library/Receipts/MacPorts*.pkg \
    /Library/StartupItems/DarwinPortsStartup \
    /Library/Tcl/darwinports1.0 \
    /Library/Tcl/macports1.0 \
    ~/.macports
    sudo find / | grep macports | sudo xargs rm
else
  echo "Macports is not installed. Moving on..."
fi
echo "Please register for an account on github.com if you haven't already done so."

read -p "Enter your full name: "  user_name
read -p "Github Username: "       github_name
read -p "Github Email: "          github_email
# SSH keys establish a secure connection between your computer and GitHub
# This script follows these instructions
# `https://help.github.com/articles/generating-ssh-keys`

# SSH Keygen
ssh-keygen -t rsa -C $github_email
ssh-add id_rsa

# Copy SSH key to the clipboard
pbcopy < ~/.ssh/id_rsa.pub

echo ""
echo "We just copied your SSH key to the clipboard."
echo "Now we're going to visit GitHub to add the SSH key"

echo "Do the following in your browser: "
echo '- Click "SSH Keys" in the left sidebar'
echo '- Click "Add SSH key"'
echo '- Paste your key into the "Key" field'
echo '- Click "Add key"'
echo '- Confirm the action by entering your GitHub password'

read -p "We'll be here until you get back from Github. Ready? Press Enter to continue."

open https://github.com/settings/ssh

read -p "SSH keys added? Press Enter to continue."

# TODO (h4w5) add assertion around ... "ssh -T git@github.com"
# download the repo for the absolute paths
if [[ ! -d $SRC_DIR ]]; then
  echo 'Downloading Installfest repo...'
  # autoupdate bootstrap file
  git clone -b $BRANCH $INSTALL_REPO $SRC_DIR
  # hide folder
  # chflags hidden $SRC_DIR # FIXME (h4w5) doesn't work on linux
else
  # update repo
  echo 'Updating repo...'
  cd $SRC_DIR
  git pull origin $BRANCH
fi
# Installs Homebrew, our package manager
# http://brew.sh/

$(which -s brew)
if [[ $? != 0 ]]; then
  echo 'Installing Homebrew...'
  # piping echo to simulate hitting return in the brew install script
  echo | ruby -e "$(curl -fsSL https://raw.github.com/mxcl/homebrew/go/install)"
fi

# Make sure we're using the latest Homebrew
brew update

# Upgrade any already-installed formulae
brew upgrade

# These formulae duplicate software provided by OS X
# though may provide more recent or bugfix versions.
brew tap homebrew/dupes

packagelist=(
  # Autoconf is an extensible package of M4 macros that produce shell scripts to
  # automatically configure software source code packages.
  autoconf

  # Automake is a tool for automatically generating Makefile.in
  automake

  # generic library support script
  libtool

  # a YAML 1.1 parser and emitter
  libyaml

  # neon is an HTTP and WebDAV client library
  # neon

  # A toolkit implementing SSL v2/v3 and TLS protocols with full-strength
  # cryptography world-wide.
  openssl

  # pkg-config is a helper tool used when compiling applications and libraries.
  pkg-config

  # a script that uses ssh to log into a remote machine
  ssh-copy-id

  # XML C parser and toolkit
  libxml2

  # a language for transforming XML documents into other XML documents.
  libxslt

  # a conversion library between Unicode and traditional encoding
  libiconv

  # generates an index file of names found in source files of various programming
  # languages.
  ctags

  # Adds history for node repl
  readline

)

brew install ${packagelist[@]}

# Tap a new formula repository from GitHub, or list existing taps.
brew tap homebrew/versions

# Ensures all tapped formula are symlinked into Library/Formula
# and prunes dead formula from Library/Formula.
brew tap --repair

# Remove outdated versions from the cellar
brew cleanup
# Version Control
brew install git

# additional git commands
brew install hub

# Add user's github info to gitconfig
# https://www.kernel.org/pub/software/scm/git/docs/git-config.html
git config --global user.name  $github_name
git config --global user.email $github_email

# set colors
git config --global color.ui always

git config --global color.branch.current   "green reverse"
git config --global color.branch.local     green
git config --global color.branch.remote    yellow

git config --global color.status.added     green
git config --global color.status.changed   yellow
git config --global color.status.untracked "red blink"

# set editor
git config --global core.editor "subl -w"

# default branch to push to
git config --global push.default current
# Our Ruby version manager
# brew install rbenv
git clone https://github.com/sstephenson/rbenv.git ~/.rbenv

# Use homebrew's directories instead of rbenv's
# echo 'export RBENV_ROOT=/usr/local/var/rbenv' >> ~/.bash_profile
# export RBENV_ROOT="/usr/local/var/rbenv"

# Add to bash_profile
echo '# added by installfest script' >> ~/.bash_profile
echo 'export PATH="$HOME/.rbenv/bin:$PATH"' >> ~/.bash_profile
echo 'if which rbenv > /dev/null; then eval "$(rbenv init -)"; fi' >> ~/.bash_profile

# enable shims and autocompletion
export PATH="$HOME/.rbenv/bin:$PATH"
eval "$(rbenv init -)"

# brew install rbenv-gem-rehash
git clone https://github.com/sstephenson/rbenv-gem-rehash.git ~/.rbenv/plugins/rbenv-gem-rehash

# Automatically install gems every time you install a new version of Ruby
# brew install rbenv-default-gems
git clone https://github.com/sstephenson/rbenv-default-gems.git ~/.rbenv/plugins/rbenv-default-gems

# # Provides an `rbenv install` command
# # ruby-build is a dependency of rbenv-default-gems, so it gets installed
# brew install ruby-build
git clone https://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build

# rbenv rehash
# source ~/.bash_profile

# Our gems to install
# skip documentation
echo "gem: --no-ri --no-rdoc" > ~/.gemrc

# TODO (phlco) replace ~/.rbenv with $RBENV_ROOT
touch ~/.rbenv/default-gems

gemlist=(
  bundler         # Maintains a consistent environment for ruby applications.
  capybara        # Acceptance test framework for web applications
  guard           # handle events on file system modifications
  jasmine         # JavaScript testing
  pg              # ruby interface for Postgres
  pry             # alternative to the standard IRB shell
  pry-coolline    # live syntax highlighting for the Pry REPL
  rails           # full stack, Web application framework
  rspec           # testing tool for Ruby
  sinatra         # a DSL for quickly creating web applications in Ruby
  sinatra-contrib # common Sinatra extensions
  github_api      # Ruby interface to github API v3
  hipchat         # HipChat HTTP API Wrapper
  awesome_print   # pretty print your Ruby objects with style
  rainbow         # colorizing printed text on ANSI terminals
)

for gem in ${gemlist[@]}; do
  echo "${gem}" >> ~/.rbenv/default-gems
done

ruby_check=$(rbenv versions | grep $BELOVED_RUBY_VERSION)

if [[ "$ruby_check" == *$BELOVED_RUBY_VERSION* ]]; then
  echo "$BELOVED_RUBY_VERSION is installed"
else
  rbenv install $BELOVED_RUBY_VERSION
fi

assert_that "Ruby is installed and links to rbenv" "which ruby" "$HOME/.rbenv/shims/ruby"

rbenv global $BELOVED_RUBY_VERSION

assert_that "Ruby version is now '${BELOVED_RUBY_VERSION}'" \
            "ruby -v | grep -q ${BELOVED_RUBY_VERSION} && echo 'true'" "true"
# Event-driven I/O server-side JavaScript environment based on V8
brew install node

# CLI tool for scaffolding out Yeoman projects
npm install -g yo

# The grunt command line interface.
npm install -g grunt-cli

# The browser package manager
npm install -g bower

# Static analysis tool for JavaScript
npm install -g jshint

# Unfancy JavaScript
npm install -g coffee-script

# Code Coverage tool for JavaScript
npm install -g istanbul

# Scaffold out a front-end web app
npm install -g generator-webapp

# Yeoman generator for Backbone.js
npm install -g generator-backbone

# Fast, unopinionated, minimalist web framework
npm install -g express

# TODO (phlco) Add or remove
# npm install -g less
# npm install -g gulp
# npm install -g browserify
# npm install -g generator-gulp-webapp
# a CLI workflow for the administration of Mac applications
# distributed as binaries
brew tap phinze/homebrew-cask
brew install brew-cask

# Instant search documentation offline
brew cask install dash

# The Browser
brew cask install google-chrome

# A Browser
brew cask install firefox

# The Chat Client
brew cask install hipchat

# The Window Manager
brew cask install spectacle
# allow spectacle to control computer
allow_control Spectacle

# The Text Editor, Sublime Text 2
brew cask install sublime-text

# Github's Text Editor
brew cask install atom

# The X Window Server
brew cask install xquartz

# Markdown Editor
brew cask install mou

# Flux, makes the color of your computer's display adapt to the time of day
brew cask install flux

# for fonts
# https://github.com/caskroom/homebrew-fonts/tree/master/Casks
brew tap caskroom/fonts

brew cask install font-source-code-pro
brew cask install font-source-sans-pro
brew cask install font-inconsolata

# Git extensions to provide high-level repository operations
# brew install git-flow
# Useful packages
packagelist=(
  # ASCII ART!!!!
  figlet

  # visualization tool for ERDs
  graphviz

  # image resizing
  imagemagick

  # PhantomJS is a headless WebKit scriptable with a JavaScript API.
  phantomjs

  # WebKit implementation of qt for Capybara testing
  qt

  # qt for mavericks
  qt4

  # Advanced in-memory key-value store that persists on disk
  redis

  # essential UNIX commands
  # TODO (phlco) ensure they're aliased in the path correctly
  coreutils

  # a self-contained, serverless, zero-configuration, transactional SQL database
  # engine.
  sqlite
)

brew install ${packagelist[@]}

# List of useful Quick Look plugins for developers
brew cask install qlcolorcode qlstephen qlmarkdown quicklook-json qlprettypatch quicklook-csv betterzipql webp-quicklook suspicious-package
#  _                    _
# | |__   ___ _ __ ___ | | ___   _
# | '_ \ / _ \ '__/ _ \| |/ / | | |
# | | | |  __/ | | (_) |   <| |_| |
# |_| |_|\___|_|  \___/|_|\_\\__,_|
# https://devcenter.heroku.com/articles/keys

echo "Heroku is a cloud platform as a service (PaaS) supporting several"
echo "programming languages."

# Heroku command-line tooling for working with the Heroku platform
brew install heroku-toolbelt

echo "If you don’t already use SSH, you’ll need to create a public/private key"
echo "pair to deploy code to Heroku. This keypair is used for the strong"
echo "cryptography and that uniquely identifies you as a developer when pushing"
echo "code changes."

# shouldn't need to generate because of generation for github
# ssh-keygen -t rsa
# autogenerate without prompt
# ssh-keygen -f id_rsa -t rsa -N ''
echo "The first time you run the heroku command, you’ll be prompted for your "
echo "credentials. Your public key will then be automatically uploaded to"
echo "Heroku. This will allow you to deploy code to all of your apps."

# PL: holding off for user interaction
heroku keys:add
# Set up Postgres
brew install postgresql

# Create a database
initdb /usr/local/var/postgres -E utf8

# Ensure that Postgres launches whenever we login
mkdir -p ~/Library/LaunchAgents
cp /usr/local/Cellar/postgresql/9.*/homebrew.mxcl.postgresql.plist ~/Library/LaunchAgents/

# Start Postgres now
launchctl load ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist

# give postgres time to load
sleep 5s

# create db matching user name so we can log in by just typing psql
createdb ${USER}
# Install Vim Plugin Manager
git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim

# Vimrc is copied over from dotfiles
# The Z shell (zsh) is a Unix shell that can be used as an interactive login
# shell and as a powerful command interpreter for shell scripting. Zsh can be
# thought of as an extended Bourne shell with a large number of improvements,
# including some features of bash, ksh, and tcsh.
# This script installs zsh, oh-my-zsh, an open source, community-driven framework
# for managing your ZSH configuration.

# Install zsh
git clone git://zsh.git.sf.net/gitroot/zsh/zsh
cp ~/.zshrc ~/.zshrc.orig

# Install oh-my-zsh
git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh
cp $SRC_DIR/settings/dotfiles/zshrc ~/.zshrc

# Syntax Highlighting
git clone git://github.com/zsh-users/zsh-syntax-highlighting.git ~/.oh-my-zsh/custom/plugins

# Set as default
# chsh -s /bin/zsh

# Resources
# https://github.com/robbyrussell/oh-my-zsh
# http://www.stevendobbelaere.be/installing-and-configuring-the-oh-my-zsh-shell/
# # Disable the "Are you sure you want to open this application?" dialog
# defaults write com.apple.LaunchServices LSQuarantine -bool false

# # Reveal IP address, hostname, OS version, etc. when clicking the clock
# # in the login window
# sudo defaults write /Library/Preferences/com.apple.loginwindow AdminHostInfo HostName

# # Disable the warning when changing a file extension
# defaults write com.apple.finder FXEnableExtensionChangeWarning -bool false

# # Only use UTF-8 in Terminal.app
# defaults write com.apple.terminal StringEncodings -array 4

# # Use a modified version of the Pro theme by default in Terminal.app
# open "${HOME}/init/Mathias.terminal"
# sleep 1 # Wait a bit to make sure the theme is loaded
# defaults write com.apple.terminal "Default Window Settings" -string "Mathias"
# defaults write com.apple.terminal "Startup Window Settings" -string "Mathias"

# # Install Sublime Text settings
# cp -r init/Preferences.sublime-settings ~/Library/Application\ Support/Sublime\ Text*/Packages/User/Preferences.sublime-settings 2> /dev/null

# spectacle
# http://support.apple.com/kb/HT5914
# codesign -s - --resource-rules=/Users/YourUserNameHere/ResourceRules-ignoring-Scripts.plist /path/to/applet.app

# https://github.com/chytreg/dotfiles/blob/c532970fb63a78b2507141b4de26b3c8e25c2bfc/bin/bootstrap

allow_control Spectacle

# also look into brew cask for installing applications
# https://github.com/Homebrew/homebrew/wiki/External-Commands

####################################################################################
# Download and set Terminal colors to MyMonokai
####################################################################################
# TODO(phlco): Make these open in the background

# Only use UTF-8 in Terminal.app
defaults write com.apple.terminal StringEncodings -array 4

# echo "Settings MyMonokai for Terminal..."
# open -g "${HOME}/.wdi-installfest/settings/sublime/MyMonokai.terminal"
# echo "done"

# osascript -e 'tell application "Terminal" to activate' \
# -e 'tell application "System Events" to tell process "Terminal" to keystroke "t" using command down' \
# -e 'tell application "Terminal" to do script "open ~/.wdi-installfest/settings/sublime/MyMonokai.terminal" in tab 2 of front window'
# -e 'tell application "System Events" to tell process "Terminal" to keystroke "w" using command down'
# -e 'tell application "System Events" to tell process "Terminal" to tell window 1 to close'
# email subject
SUBJECT="Log Report"
# Email To ?
EMAIL="philco@ga.co"
# Email text/message
EMAILMESSAGE="/tmp/emailmessage.txt"
cat "$HOME/.wdi/install.log"> $EMAILMESSAGE
# send an email using /bin/mail
mail -s "$SUBJECT" "$EMAIL" < $EMAILMESSAGE

# FIXME (phlco) this reports broken pipe in ubuntu
# run exec $SHELL at end?
# atom . doesn't work.
# subl . works
