#!/usr/bin/env bash -i
# testing interactive mode
#
#  _           _        _ _  __           _
# (_)_ __  ___| |_ __ _| | |/ _| ___  ___| |_
# | | '_ \/ __| __/ _` | | | |_ / _ \/ __| __|
# | | | | \__ \ || (_| | | |  _|  __/\__ \ |_
# |_|_| |_|___/\__\__,_|_|_|_|  \___||___/\__|
#
# Installation, Setup and Dotfile Creation Script
# for Students of General Assemb.ly's WDI Program

# Author: Phillip Lamplugh, GA Instructor (2014)
# Contributions: PJ Hughes, GA Instructor (2014)

# Resources
#
# https://github.com/thoughtbot/laptop
# https://github.com/toranb/ubuntu-development-machine
# https://github.com/divio/osx-bootstrap
# https://github.com/paulirish/dotfiles
# https://github.com/mathiasbynens/dotfiles/
# https://github.com/ndbroadbent/dotfiles

# References
#
# http://www.sudo.ws/
# http://www.gnu.org/software/bash/manual/bashref.html
# http://www.shellcheck.net
# http://explainshell.com/
#-------------------------------------------------------------------------------
# Logging
#-------------------------------------------------------------------------------

mkdir -p ~/.wdi; exec > >(tee ~/.wdi/install.log); exec 2>&1

echo "Script executed at $(date)"
echo ""

#-------------------------------------------------------------------------------
# Set text formatting
#-------------------------------------------------------------------------------

# Reset formatting
RESET=$(      tput sgr0)

# Foreground color
BLACK=$(      tput setaf 0)
RED=$(        tput setaf 1)
GREEN=$(      tput setaf 2)
YELLOW=$(     tput setaf 3)
BLUE=$(       tput setaf 4)
MAGENTA=$(    tput setaf 5)
CYAN=$(       tput setaf 6)
WHITE=$(      tput setaf 9)
# ORANGE=$(     tput setaf 172)
# PURPLE=$(     tput setaf 141)

# Background color
BG_BLACK=$(   tput setab 0)
BG_RED=$(     tput setab 1)
BG_GREEN=$(   tput setab 2)
BG_YELLOW=$(  tput setab 3)
BG_BLUE=$(    tput setab 4)
BG_MAGENTA=$( tput setab 5)
BG_CYAN=$(    tput setab 6)
BG_WHITE=$(   tput setab 9)
# BG_ORANGE=$(  tput setab 172)

# Style
UNDERLINE=$(  tput smul)
NOUNDERLINE=$(tput rmul)
BOLD=$(       tput bold)
ITALIC=$(     tput sitm)

#-------------------------------------------------------------------------------
# Functions
#-------------------------------------------------------------------------------

#######################################
# ABRB
# Arguments:
#   Message
#   Attribution
# Returns:
#   None
#######################################
function quoth_the_bard () {
  local message=$1
  local attribution=$2
  echo ""
  echo "$YELLOW$message$RESET"
  echo "$PURPLE$attribution$RESET"
}

#######################################
# Upcase error message and exit script
# Arguments:
#   Error message
# Returns:
#   None
#######################################

function fie () {
  local message=$(echo $1 | tr 'a-z' 'A-Z')
  echo ""
  echo "$RED$message$RESET"
  exit
}


#######################################
# Announce our acts
# Arguments:
#   Act Number
# Returns:
#   None
#######################################
function figlet_announces () {
  clear
  local act=$1
  figlet -f ogre $act
}

#######################################
# Waits for user input
# Arguments:
#   Message
# Returns:
#   None
#######################################
function pause_awhile () {
   read -p "$* Press Enter to continue"
}

#######################################
# Mounts DMG and moves to Applications
# Arguments:
#   File name
# Returns:
#   None
#######################################
function install_dmg () {
  echo 'Hark, a dmg!'
  file_name="$1"
  MOUNTPOINT="/Volumes/MountPoint"
  IFS="
  "
  hdiutil attach -mountpoint $MOUNTPOINT "$file_name.dmg"
  app=$(find $MOUNTPOINT 2>/dev/null -maxdepth 2 -iname \*.app)
  if [[ ! -z "$app" ]]; then
    cp -a "$app" /Applications/
  fi
  echo 'Hark! A pkg!'
  pkg=$(find $MOUNTPOINT 2>/dev/null -maxdepth 2 -iname \*.pkg)
  if [[ ! -z "$pkg" ]]; then
    # PL: Need to handle harddrive names that aren't Macintosh HD
    sudo installer -package $pkg -target /
  fi
  hdiutil detach $MOUNTPOINT
}

#######################################
# Unzip Zip and move App to Applications
# Arguments:
#   File name
# Returns:
#   None
#######################################
function install_zip () {
  file_name="$1"
  echo 'Hark! A zip!'
  mkdir "$file_name"
  unzip "$file_name.zip" -d "$file_name"
  mv $file_name/*.app /Applications
}

#######################################
# Checks for the existence of a file
# Arguments:
#   File name
# Returns:
#   1 or 0
#######################################
function know_you_not_of () {
  file_name="$1"
  file_count=$(find /Applications -name "$file_name.app" | wc -l)
  if [[ $file_count -gt 0 ]]; then
    echo "$file_name is already here.";
    return 1
  else
    return 0
  fi
}

#######################################
# Downloads and installs apps from zips, dmgs, and pkgs.
# Arguments:
#   File name
#   URL
# Returns:
#   None
#######################################
function lend_me_your () {
  file_name="$1"
  url="$2"
  ext=${url: -4}
  if know_you_not_of "$file_name" ; then
    curl -L -o "$file_name$ext" $url
    # enter stage left...
    case "$ext" in
      ".dmg")  install_dmg "$file_name";;
      ".zip")  install_zip "$file_name";;
      *) echo "Not Processed";;
    esac
  fi
  # Out spot
  rm -rf "$file_name$ext"
  rm -rf "$file_name"
}

#######################################
# Allow apps to control your computer
# Arguments:
#   File name
# Returns:
#   None
#######################################
allow_control() {
  if [[ "$OSTYPE" =~ ^darwin13.*$ ]]; then
    for app; do
      APP_ID="$(osascript -e "id of app \"$app\"")"
      if [[ -n "$APP_ID" ]]; then
        sudo sqlite3 /Library/Application\ Support/com.apple.TCC/TCC.db "INSERT or REPLACE INTO access values ('kTCCServiceAccessibility', '$APP_ID', 0, 1, 0, NULL);"
      fi
    done
  else
    echo "allow_control works only on Mavericks"
  fi
}
BELOVED_RUBY_VERSION="2.1.2"
CURRENT_STABLE_RUBY_VERSION="2.1.2"

# TODO backport this into master and mac...
SRC_DIR=~/.wdi/installfest
SETTINGS=$SRC_DIR/settings
INSTALL_REPO=https://github.com/ga-instructors/installfest_script.git
MINIMUM_OS="10.7.0"

# This refers to the branch of our repo that we are using (for cloning).
BRANCH=version2
# Capture the user's password
sudo echo "Thanks."

# Update existing `sudo` time stamp until script has finished
while true; do sudo -n true; sleep 60; kill -0 "$$" || exit; done 2>/dev/null &

# TODO (phlco) does this actually work?
# Check for recommended software updates
sudo softwareupdate -i -r --ignore iTunes

# Ensure user has full control over their folder
sudo chown -R ${USER} ~

# Repair disk permission
diskutil repairPermissions /

# Determine OS version

osx_version=$(sw_vers -productVersion)
# Force the user to upgrade if they're below 10.7
echo "You're running OSX $osx_version"
if [[ "$osx_version" < "$MINIMUM_OS" ]]; then
  fie "Please upgrade to the latest OS then rerun this script."
fi

# Check that command line tools are installed
case $osx_version in
  *10.9*) cmdline_version="CLTools_Executables" ;; # Mavericks
  *10.8*) cmdline_version="DeveloperToolsCLI"   ;; # Mountain Lion
  *10.7*) cmdline_version="DeveloperToolsCLI"   ;; # Lion
  *) echo "Please upgrade your OS"; exit 1;;
esac

# Check for Command Line Tools based on OS versions
if [ ! -z $(pkgutil --pkgs=com.apple.pkg.$cmdline_version) ]; then
  echo "Command Line Tools are installed";
elif [[ $osx_version < "10.9" ]]; then
  echo "Command Line Tools are not installed"
  echo "Register for a Developer Account"
  echo "Download the Command Lion Tools from"
  echo "https://developer.apple.com/downloads/index.action"
  echo "Then rerun this script"
  exit 1
else
  echo "Command Line Tools are not installed"
  echo "run '$ sudo xcodebuild -license' then"
  echo "'$ xcode-select --install'"
  echo "Then rerun this script."
  exit 1
fi

# Because we're going to use rbenv and homebrew we need to remove RVM and MacPorts
# This script checks for and removes previous installs of macports and RVM

# Uninstall RVM
# http://stackoverflow.com/questions/3950260/howto-uninstall-rvm
if hash rvm 2>/dev/null || [ -d ~/.rvm ]; then
  yes | rvm implode
  rm -rf ~/.rvm
  echo "RVM has been removed."
else
  echo "RVM is not installed. Moving on..."
fi

# # http://blog.coolaj86.com/articles/installing-ruby-on-ubuntu-12-04.html
# sudo apt-get remove --purge ruby-rvm ruby
# sudo rm -rf /usr/share/ruby-rvm /etc/rmvrc /etc/profile.d/rvm.sh
#
# # See if there is anything
# ls -d ~/.rvm*
# ls -d ~/.gem*
# ls -d ~/.bundle*
# # Delete them (ignoring those that don't exist)
# rm -rf ~/.rvm* ~/.gem/ ~/.bundle*
# Because we're going to use rbenv and homebrew we need to remove RVM and MacPorts
# This script checks for and removes previous installs of macports and RVM

# Uninstall Macports
# http://guide.macports.org/chunked/installing.macports.uninstalling.html
if hash port 2>/dev/null || [[ $(find /opt/local -iname macports 2>/dev/null) ]]; then
  echo "Removing MacPorts"
    macports=$(find /opt/local -iname macports)
    for f in $macports; do
      rm -rf $f
    done
  # carthago delenda est
  sudo port -fp uninstall installed
  sudo rm -rf \
    /opt/local \
    /Applications/DarwinPorts \
    /Applications/MacPorts \
    /Library/LaunchDaemons/org.macports.* \
    /Library/Receipts/DarwinPorts*.pkg \
    /Library/Receipts/MacPorts*.pkg \
    /Library/StartupItems/DarwinPortsStartup \
    /Library/Tcl/darwinports1.0 \
    /Library/Tcl/macports1.0 \
    ~/.macports
    sudo find / | grep macports | sudo xargs rm
else
  echo "Macports is not installed. Moving on..."
fi
echo "Please register for an account on github.com if you haven't already done so."

read -p "Enter your full name: "  user_name
read -p "Github Username: "       github_name
read -p "Github Email: "          github_email
# SSH keys establish a secure connection between your computer and GitHub
# This script follows these instructions
# `https://help.github.com/articles/generating-ssh-keys`

# SSH Keygen
ssh-keygen -t rsa -C $github_email
ssh-add id_rsa

# Copy SSH key to the clipboard
pbcopy < ~/.ssh/id_rsa.pub

echo ""
echo "We just copied your SSH key to the clipboard."
echo "Now we're going to visit GitHub to add the SSH key"

echo "Do the following in your browser: "
echo '- Click "SSH Keys" in the left sidebar'
echo '- Click "Add SSH key"'
echo '- Paste your key into the "Key" field'
echo '- Click "Add key"'
echo '- Confirm the action by entering your GitHub password'

pause_awhile "We'll be here until you get back from Github. Ready?"

open https://github.com/settings/ssh

pause_awhile "SSH keys added?"
# download the repo for the absolute paths
if [[ ! -d $SRC_DIR ]]; then
  echo 'Downloading Installfest repo...'
  # autoupdate bootstrap file
  git clone -b $BRANCH $INSTALL_REPO $SRC_DIR
  # hide folder
  # chflags hidden $SRC_DIR # FIXME (h4w5) doesn't work on linux
else
  # update repo
  echo 'Updating repo...'
  cd $SRC_DIR
  git pull origin $BRANCH
fi
# Installs Homebrew, our package manager
# http://brew.sh/

$(which -s brew)
if [[ $? != 0 ]]; then
  echo 'Installing Homebrew...'
  ruby -e "$(curl -fsSL https://raw.github.com/mxcl/homebrew/go/install)"
fi

# Make sure we're using the latest Homebrew
brew update

# Upgrade any already-installed formulae
brew upgrade

# These formulae duplicate software provided by OS X
# though may provide more recent or bugfix versions.
brew tap homebrew/dupes

packagelist=(
  # Autoconf is an extensible package of M4 macros that produce shell scripts to
  # automatically configure software source code packages.
  autoconf

  # Automake is a tool for automatically generating Makefile.in
  automake

  # generic library support script
  libtool

  # a YAML 1.1 parser and emitter
  libyaml

  # neon is an HTTP and WebDAV client library
  # neon

  # A toolkit implementing SSL v2/v3 and TLS protocols with full-strength
  # cryptography world-wide.
  openssl

  # pkg-config is a helper tool used when compiling applications and libraries.
  pkg-config

  # a script that uses ssh to log into a remote machine
  ssh-copy-id

  # XML C parser and toolkit
  libxml2

  # a language for transforming XML documents into other XML documents.
  libxslt

  # a conversion library between Unicode and traditional encoding
  libiconv

  # generates an index file of names found in source files of various programming
  # languages.
  ctags

  # Adds history for node repl
  readline

)

brew install ${packagelist[@]}

# Tap a new formula repository from GitHub, or list existing taps.
brew tap homebrew/versions

# Ensures all tapped formula are symlinked into Library/Formula
# and prunes dead formula from Library/Formula.
brew tap --repair

# Remove outdated versions from the cellar
brew cleanup
# Version Control
brew install git

# additional git commands
brew install hub

# Add user's github info to gitconfig
# https://www.kernel.org/pub/software/scm/git/docs/git-config.html
git config --global user.name  $github_name
git config --global user.email $github_email

# set colors
git config --global color.ui always

git config --global color.branch.current   "green reverse"
git config --global color.branch.local     green
git config --global color.branch.remote    yellow

git config --global color.status.added     green
git config --global color.status.changed   yellow
git config --global color.status.untracked "red blink"

# set editor
git config --global core.editor "subl -w"

# default branch to push to
git config --global push.default current
# Our Ruby version manager
# brew install rbenv
 git clone https://github.com/sstephenson/rbenv.git ~/.rbenv

# Automatically runs rbenv rehash every time you install or uninstall a gem.
# brew install rbenv-gem-rehash
git clone https://github.com/sstephenson/rbenv-gem-rehash.git ~/.rbenv/plugins/rbenv-gem-rehash

# Provides an `rbenv install` command
# brew install ruby-build
git clone https://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build

# Add to path
export PATH="$HOME/.rbenv/bin:$PATH"

# enable shims and autocompletion
eval "$(rbenv init -)"

# Automatically install gems every time you install a new version of Ruby
# brew install rbenv-default-gems
git clone https://github.com/sstephenson/rbenv-default-gems.git ~/.rbenv/plugins/rbenv-default-gems
# Our gems to install
# skip documentation
echo "gem: --no-ri --no-rdoc" > ~/.gemrc

# TODO(phlco) move these to a default gem file that gets copied over

# Maintains a consistent environment for ruby applications.
echo "bundler" >> ~/.rbenv/default-gems

# Acceptance test framework for web applications
echo "capybara" >> ~/.rbenv/default-gems

# handle events on file system modifications
echo "guard" >> ~/.rbenv/default-gems

# JavaScript testing
echo "jasmine" >> ~/.rbenv/default-gems

# ruby interface for Postgres
echo "pg" >> ~/.rbenv/default-gems

# alternative to the standard IRB shell
echo "pry" >> ~/.rbenv/default-gems

# live syntax highlighting for the Pry REPL
echo "pry-coolline" >> ~/.rbenv/default-gems

# full stack, Web application framework
echo "rails" >> ~/.rbenv/default-gems

# testing tool for Ruby
echo "rspec" >> ~/.rbenv/default-gems

# a DSL for quickly creating web applications in Ruby
echo "sinatra" >> ~/.rbenv/default-gems

# common Sinatra extensions
echo "sinatra-contrib" >> ~/.rbenv/default-gems

# Ruby interface to github API v3
echo "github_api" >> ~/.rbenv/default-gems

# HipChat HTTP API Wrapper
echo "hipchat" >> ~/.rbenv/default-gems

# pretty print your Ruby objects with style
echo "awesome_print" >> ~/.rbenv/default-gems

# colorizing printed text on ANSI terminals
echo "rainbow" >> ~/.rbenv/default-gems
ruby_check=$(rbenv versions | grep $BELOVED_RUBY_VERSION)

if [[ "$ruby_check" == *$BELOVED_RUBY_VERSION* ]]; then
  echo "$BELOVED_RUBY_VERSION is installed"
else
  rbenv install $BELOVED_RUBY_VERSION
fi

rbenv rehash
# echo "${BOLD}Ruby version is now: '`ruby -v`'...${RESET}"
# echo "${BOLD}Ruby now found at: `which ruby`...${RESET}"
#
# echo "${BOLD}Setting the global ruby as '${BELOVED_RUBY_VERSION}'...${RESET}"

rbenv global $BELOVED_RUBY_VERSION

# echo "${BOLD}Ruby version is now: '`ruby -v`'...${RESET}"
# echo "${BOLD}Ruby now found at: `which ruby`...${RESET}"
#
# echo "${BOLD}Adding the rbenv binary directory to path, and prepending the .shims...${RESET}"

rbenv rehash # happens at end of eval above I believe (h4w5)

# echo "${BOLD}Path is now:${RESET} ${PATH}"
# echo "${BOLD}Ruby version is now: '`ruby -v`'...${RESET}"
# echo "${BOLD}Ruby now found at: `which ruby`...${RESET}"

# echo "${BOLD}Path is now:${RESET} ${PATH}"
# echo "${BOLD}Ruby version is now: '`ruby -v`'...${RESET}"
# echo "${BOLD}Ruby now found at: `which ruby`...${RESET}"
# echo "${BOLD}Gem environment is now:${RESET}"
# gem env

# export PATH="$HOME/.rbenv/bin:$PATH"
# eval "$(rbenv init -)"
